Require Import Program.
Require Import LogicalRelations.


(** * Preliminaries *)

(** Effect signature *)

Record esig :=
  {
    op :> Type;
    ar : op -> Type;
  }.

Arguments ar {_}.


(** * Multi-sorted signatures *)

Module MSig.

  Record t :=
    {
      sort : Type;
      arity : Type;
      action : sort -> arity -> Type;
      resume : arity -> sort -> Type;
      init : arity;
    }.

  (** Transition system *)

  Record ts (Σ : t) :=
    {
      cont : arity Σ -> Type;
      state : sort Σ -> Type;
      step_in {u v} : cont u -> resume Σ u v -> state v -> Prop;
      step_out {u v} : state u -> action Σ u v -> cont v -> Prop;
      initial_cont : cont (init Σ);
    }.

  Coercion ts : t >-> Sortclass.

  (** Function-based behavior *)

  (** This will not work but we could do an itree-type coinductive thing. *)

  Inductive strat (Σ : t) (u : sort Σ) : Type :=
    | do {v} (a : action Σ u v) (k : forall {w}, resume Σ v w -> strat Σ w).

  Definition beh Σ := forall {u}, resume Σ (init Σ) u -> strat Σ u.

  (** Example: object semantics *)

  Module Obj.

    (** Definition of A -->> B *)

    Section OBJ.
      Context {A B : esig}.

      Inductive arity :=
        | init
        | extern (q : B) (m : A).

      Inductive action (q : B) : arity -> Type :=
        | ask (m : A) : action q (extern q m)
        | answer (r : ar q) : action q init.

      Inductive resume : arity -> B -> Type :=
        | incoming q : resume init q
        | continue q m : ar m -> resume (extern q m) q.

      Definition m : MSig.t :=
        {|
          MSig.sort := B;
          MSig.arity := arity;
          MSig.action := action;
          MSig.resume := resume;
          MSig.init := init;
        |}.

    End OBJ.

    Arguments Obj.m : clear implicits.
    Canonical Structure Obj.m.
    Infix "-->>" := Obj.m (at level 60).

    (** Compositional structure *)

    Module Id.
      Section ID.
        Context {A : esig}.

        Inductive cont : arity -> Type :=
          | init_cont : cont init
          | extern_cont (q : A) : cont (extern q q).

        Inductive state : A -> Type :=
          | call (q : A) : state q
          | ret {q} (r : ar q) : state q.

        Inductive step_in : forall {u v}, cont u -> resume u v -> state v -> Prop :=
          | step_in_call q : step_in init_cont (incoming q) (call q)
          | step_in_ret q r : step_in (extern_cont q) (continue q q r) (ret r).

        Inductive step_out : forall {u v}, state u -> action u v -> cont v -> Prop :=
          | step_out_call q : step_out (call q) (ask q q) (extern_cont q)
          | steo_out_ret q r : step_out (ret r) (answer q r) init_cont.

      End ID.
    End Id.

    Definition id A : A -->> A :=
      {|
        MSig.cont := Id.cont;
        MSig.state := Id.state;
        MSig.step_in := @Id.step_in A;
        MSig.step_out := @Id.step_out A;
        MSig.initial_cont := Id.init_cont;
      |}.

    Module Comp.
      Section COMP.
        Context {A B C : esig} (L1 : B -->> C) (L2 : A -->> B).

        (** Complicated states etc. ... *)

      End COMP.
    End Comp.

  End Obj.

End MSig.


(** * Template-based *)

Module Tpl.
  
  (** The symmetry of sort and arities in multi-signatures
    can be captured in the following way. *)

  (** ** Quivers *)

  (** We consider templates which are freely generated by quivers,
    which I define here in "unbundled" form: [V] is the type of objects;
    [template V] gives a set of arrows between any two objects. *)

  Definition template (V : Type) := V -> V -> Type.

  (** A structure-preserving transformation between templates maps
    source objects to target objects, and source arrows to target arrows
    between the corresponding objects. Again, I represent it in
    unbundled form using dependent types. *)

  Definition tmor {U V} (Tu : template U) (Tv : template V) (f : U -> V) :=
    forall u1 u2, Tu u1 u2 -> Tv (f u1) (f u2).

  (** A quiver indexed over a template *)

  Definition space {V} (T : template V) (S : V -> Type) :=
    forall {u v}, T u v -> S u -> S v -> Type.

  (** ** Free category *)

  (** The paths in a quiver template constitute the free category on
    that quiver. *)

  Inductive path {V} (T : template V) : template V :=
    | pnil u : path T u u
    | pcons u v w : T u v -> path T v w -> path T u w.

  Arguments pnil {V T u}.
  Arguments pcons {V T u v w}.

  Declare Scope path_scope.
  Delimit Scope path_scope with path.
  Bind Scope path_scope with path.
  Notation "[ ]" := pnil : path_scope.
  Notation "[ x , .. , y ]" := (pcons x .. (pcons y pnil) .. ) : path_scope.

  Inductive seq {V} {T: template V} {S: V -> Type} (M: space T S): space (path T) S :=
    | snil {u} {s : S u} :
        seq M u u pnil s s
    | scons {u v w} {puv: T u v} {pvw: path T v w} {q: S u} {r: S v} {s: S w} :
        M u v puv q r ->
        seq M v w pvw r s ->
        seq M u w (pcons puv pvw) q s.

  Arguments snil {V T S M u s}.
  Arguments scons {V T S M u v w puv pvw q r s}.

  Declare Scope seq_scope.
  Delimit Scope seq_scope with seq.
  Bind Scope seq_scope with seq.
  Notation "[ ]" := snil : seq_scope.
  Notation "[ x , .. , y ]" := (scons x .. (scons y snil) .. ) : seq_scope.

  (** ** Template of games *)

  Inductive polarity := pos | neg.
  Notation "⊕" := pos.
  Notation "⊖" := neg.

  Inductive Tgame : template polarity :=
    | O : Tgame ⊕ ⊖
    | P : Tgame ⊖ ⊕.

  (** ** A signature is just a bundled space *)

  Record sig {V} (T : template V) (v0 : V) :=
    {
      position : V -> Type;
      move : space T position;
      init_pos : position v0;
    }.

  Arguments position {_ _ _}.
  Arguments move {_ _ _}.
  Arguments init_pos {_ _ _}.
  Definition msig := sig Tgame ⊕.

  (** ** Effect signature *)

  (** Compared with before, we will first embed effect into multi-signatures,
    then use Mellies-type techniques to calculate the hom space. *)

  Module ESig.
    Section ESIG.
      Context (A : esig).

      Inductive position : polarity -> Type :=
        | wait : position ⊕
        | handle (q : A) : position ⊖.

      Inductive move : forall {u v}, Tgame u v -> position u -> position v -> Type :=
        | ask (q : A) : move O wait (handle q)
        | answer {q : A} (r : ar q) : move P (handle q) wait.

      Definition to_msig : msig :=
        {|
          Tpl.position := position;
          Tpl.move := @move;
          Tpl.init_pos := wait;
        |}.
    End ESIG.
  End ESig.

  Coercion ESig.to_msig : esig >-> msig.

  (** ** Template of strategies *)

  (** In the template game paper by Melliès, the template of
    strategies has only the three objects for which notations have
    been defined below. This makes sense, but in our context using
    a pair of the left and right projections instead helps with
    our encoding of constraints as types indices. We expect [(⊖,⊕)]
    never to appear in any context, and elimination to operate on
    the arrows in [Tstrat] rather than [strat] itself. *)

  Definition strat : Type := polarity * polarity.
  Notation "⊕⊕" := (⊕,⊕).
  Notation "⊕⊖" := (⊕,⊖).
  Notation "⊖⊖" := (⊖,⊖).

  Inductive Tstrat : template strat :=
    | Ot : Tstrat ⊕⊕ ⊕⊖
    | Ps : Tstrat ⊕⊖ ⊖⊖
    | Os : Tstrat ⊖⊖ ⊕⊖
    | Pt : Tstrat ⊕⊖ ⊕⊕.

  (** *** Projections *)

  Definition πs (u : strat) : polarity := fst u.
  Definition πt (u : strat) : polarity := snd u.
  Definition πx (u : strat) : polarity := match u with ⊕⊕ | ⊖⊖ => ⊕ | _ => ⊖ end.

  (*
  Definition πs (u : strat) : polarity := match u with ⊕⊕ | ⊕⊖ => ⊕ | _ => ⊖ end.
  Definition πt (u : strat) : polarity := match u with ⊕⊖ | ⊖⊖ => ⊖ | _ => ⊕ end.
  Definition πx (u : strat) : polarity := match u with ⊕⊕ | ⊖⊖ => ⊕ | _ => ⊖ end.
   *)

  Definition sts : tmor Tstrat (path Tgame) πs :=
    fun _ _ e =>
      match e with
      | Ot => pnil
      | Ps => [O]%path
      | Os => [P]%path
      | Pt => pnil
      end.

  Definition stt : tmor Tstrat (path Tgame) πt :=
    fun _ _ e =>
      match e with
      | Ot => [O]%path
      | Ps => pnil
      | Os => pnil
      | Pt => [P]%path
      end.

  Definition stx : tmor Tstrat Tgame πx :=
    fun _ _ e =>
      match e with
      | Ot => O
      | Ps => P
      | Os => O
      | Pt => P
      end.

  (** *** Strategy signature *)

  (*
  Module Hom.
    Section HOM.
      Context (A B : msig).

      Variant position : polarity -> Type :=
        ph (t : strat) :
          Tpl.position A (πs t) ->
          Tpl.position B (πt t) ->
          position (πx t).

      (** A move in [A --o B] is a sequence of moves in each component
        which synchronize with a single step [t] in [Tstrat]. *)

      Variant move : space Tgame position :=
        | tr {u v : strat} (t : Tstrat u v) :
          forall φs ψs, seq (Tpl.move A) _ _ (sts _ _ t) φs ψs ->
          forall φt ψt, seq (Tpl.move B) _ _ (stt _ _ t) φt ψt ->
          move _ _ (stx _ _ t) (ph u φs φt) (ph v ψs ψt).
    End HOM.
  End Hom.

  Arguments Hom.pos {_ _}.
  Arguments Hom.mv {_ _ _ _} _ {_ _} _ {_ _} _.

  Definition hom (A B : msig) : msig :=
    {|
      position := Hom.position A B;
      move := Hom.move A B;
      init_pos := Hom.pos ⊕⊕ (init_pos A) (init_pos B);
    |}.

  Infix "--o" := hom (at level 60).
  *)

  Module Hom.
    Section HOM.
      Context (A B : msig).

      Variant position : strat -> Type :=
        | pos {us ut} :
            Tpl.position A us ->
            Tpl.position B ut ->
            position (us, ut).

      (** A move in [A --o B] is a sequence of moves in each component
        which synchronize with a single step [t] in [Tstrat]. *)

      Variant move : space Tstrat position :=
        | mv {us ut vs vt} (t : Tstrat (us,ut) (vs,vt)) :
          forall φs ψs, seq (Tpl.move A) _ _ (sts _ _ t) φs ψs ->
          forall φt ψt, seq (Tpl.move B) _ _ (stt _ _ t) φt ψt ->
          move (us,ut) (vs,vt) t (pos φs φt) (pos ψs ψt).
    End HOM.
  End Hom.

  Arguments Hom.pos {_ _}.
  Arguments Hom.mv {_ _ _ _} _ {_ _} _ {_ _} _.

  Definition hom (A B : msig) : sig Tstrat ⊕⊕ :=
    {|
      position := Hom.position A B;
      move := @Hom.move A B;
      init_pos := Hom.pos ⊕ ⊕ (init_pos A) (init_pos B);
    |}.

  Infix "--o" := hom (at level 60).

  (** *** Transition systems *)

  Record ts {V T v0} (Σ : @sig V T v0) :=
    {
      state {u} : position Σ u -> Type;
      init_state : state (init_pos Σ);

      (** Having this be in Prop is awkward because the fact that we
        use [seq (move Σ)] means that we can still generate different
        trajectories. In other words, the category is generated from a
        graph instead of a multigraph but is not necessarily a
        poset. Alternatives would be to not pretend it's
        proof-irrelevant, or to specify the category directly rather
        than the generating graph. *)
      step {u v t φu φv}:
        seq (move Σ) u v t φu φv -> state φu -> state φv -> Prop;
    }.

  Coercion ts : sig >-> Sortclass.

  Module Id.
    Section ID.
      Context {A : msig}.

      (** A state of the identity transition system [id : A --o A] is
        just a position in the game [A]. However we have to make sure
        such states are properly indexed over the template of
        strategies. One approach would be to define [cc : polarity -> strat]
        which simply duplicates a polarity into ⊕⊕ or ⊖⊖, and define:
        <<<
        Variant state : forall {u}, position (A --o A) u -> Type :=
          | st {u} (φ : position A u) : state (Hom.pos (cc u) φ φ).
        >>>
        However this runs into the issue that (πs ∘ cc) vs. (πt ∘ cc)
        is not convertible although they are equal.

        To work around this we could use a definition like:
        <<<
        Variant state : forall {u}, position (A --o A) u -> Type :=
          | st_pos (φ : position A ⊕) : state (Hom.pos ⊕⊕ φ φ)
          | st_neg (φ : position A ⊖) : state (Hom.pos ⊖⊖ φ φ).
        >>>
        This is also not great because it obfuscates the underlying
        structure and makes it harder to exploit it. For example,
        under this approach we would need to define steps as:
        <<<
        Variant step : forall {u v t φu φv}, seq _ u v t φu φv -> state φu -> state φv -> Prop :=
          | step_O (φ : position A ⊕) (ψ : position A ⊖) (t : move A _ _ O φ ψ):
              step [Hom.mv Ot [] [t], Hom.mv Ps [t] []] (st_pos φ) (st_neg ψ)
          | step_P (φ : position A ⊖) (ψ : position A ⊕) (t : move A _ _ P φ ψ):
              step [Hom.mv Os [t] [], Hom.mv Pt [] [t]] (st_neg φ) (st_pos ψ).
        >>>
        To an extent, the above defeats the purpose and elegance of of templates.

        Thankfully, after defining [strat] as a pair, we can proceed
        in the following way. *)

      Definition Tcc {u v} (t : Tgame u v) : path Tstrat (u,u) (v,v) :=
        match t with
          | O => [Ot, Ps]
          | P => [Os, Pt]
        end.

      Variant state : forall {u}, position (A --o A) u -> Type :=
        | st {u} (φ : position A u) : state (Hom.pos u u φ φ).

      Variant step : forall {u v t φu φv}, seq (Hom.move A A) u v t φu φv -> state φu -> state φv -> Prop :=
        | step_intro {u v t φ ψ}
            (m : seq (Hom.move A A) (u,u) (v,v) (Tcc t) (Hom.pos u u φ φ) (Hom.pos v v ψ ψ)) :
            step m (st φ) (st ψ).

    End ID.
  End Id.


  Definition id (A : msig) : A --o A :=
    {|
      state := @Id.state A;
      init_state := Id.st (init_pos A);
      step := @Id.step A;
    |}.

(* ================ HALF-BAKED BELOW THIS LINE ================ *)

  (** *** Interactions *)

  Module Comp.

    (** ** Template *)

    Inductive int := PPP | PPN | PNN | NNN.
    Notation "⊕⊕⊕" := PPP.
    Notation "⊕⊕⊖" := PPN.
    Notation "⊕⊖⊖" := PNN.
    Notation "⊖⊖⊖" := NNN.

    Inductive Tint : template int :=
      | OR : Tint ⊕⊕⊕ ⊕⊕⊖
      | RL : Tint ⊕⊕⊖ ⊕⊖⊖
      | LP : Tint ⊕⊖⊖ ⊖⊖⊖
      | OL : Tint ⊖⊖⊖ ⊕⊖⊖ 
      | LR : Tint ⊕⊖⊖ ⊕⊕⊖
      | RO : Tint ⊕⊕⊖ ⊕⊕⊕.

    (** ** Projections *)

    Definition π1 (i : int) : polarity :=
      match i with
        | ⊕⊕⊕ => ⊕
        | ⊕⊕⊖ => ⊕
        | ⊕⊖⊖ => ⊕
        | ⊖⊖⊖ => ⊖
      end.

    Definition π2 (i : int) : polarity :=
      match i with
        | ⊕⊕⊕ => ⊕
        | ⊕⊕⊖ => ⊕
        | ⊕⊖⊖ => ⊖
        | ⊖⊖⊖ => ⊖
      end.

    Definition π3 (i : int) : polarity :=
      match i with
        | ⊕⊕⊕ => ⊕
        | ⊕⊕⊖ => ⊖
        | ⊕⊖⊖ => ⊖
        | ⊖⊖⊖ => ⊖
      end.

    Definition πL (i : int) : strat :=
      match i with
        | ⊕⊕⊕ => ⊕⊕
        | ⊕⊕⊖ => ⊕⊕
        | ⊕⊖⊖ => ⊕⊖
        | ⊖⊖⊖ => ⊖⊖
      end.

    Definition πR (i : int) : strat :=
      match i with
        | ⊕⊕⊕ => ⊕⊕
        | ⊕⊕⊖ => ⊕⊖
        | ⊕⊖⊖ => ⊖⊖
        | ⊖⊖⊖ => ⊖⊖
      end.

    Definition πX (i : int) : strat :=
      match i with
        | ⊕⊕⊕ => ⊕⊕
        | ⊕⊕⊖ => ⊕⊖
        | ⊕⊖⊖ => ⊕⊖
        | ⊖⊖⊖ => ⊖⊖
      end.

    Open Scope path_scope.
    Eval cbv in πL ⊕⊖⊖.

    Definition ileft : tmor Tint (path Tstrat) πL :=
      fun _ _ e =>
        match e with
          | OR => []
          | RL => [Ot]
          | LP => [Ps]
          | OL => [Os]
          | LR => [Pt]
          | RP => []
        end.

    Definition iright : tmor Tint (path Tstrat) πR :=
      fun _ _ e =>
        match e with
          | OR => [Ot]
          | RL => [Ps]
          | LP => []
          | OL => []
          | LR => [Os]
          | RP => [Pt]
        end.

    Definition iext : tmor Tint (path Tstrat) πX :=
      fun _ _ e =>
        match e with
          | OR => [Ot]
          | RL => []
          | LP => [Ps]
          | OL => [Os]
          | LR => []
          | RP => [Pt]
        end.

    (** Composition *)

    Section COMP.
      Context {A B C : msig} (f : B --o C) (g : A --o B).

      Variant state : forall {u}, position (A --o C) u -> Type :=
        | st {ua ub uc} :
          forall {φa : position A ua} {φb : position B ub} {φc : position C uc},
            Tpl.state _ f (Hom.pos ub uc φb φc) ->
            Tpl.state _ g (Hom.pos ua ub φa φb) ->
            state (Hom.pos ua uc φa φc).

      Variant step : forall {u v t φu φv}, seq (Hom.move A C) u v t φu φv -> state φu -> state φv -> Prop :=
        | step_intro {ua ub uc va vb vc t} φa φb φc ψa ψb ψc m1 s1 s1' m2 s2 s2' :
            Tpl.step f (ub,uc) (vb,vc) (iright (ua,ub,uc) (va,vb,vc) t)
                       (Hom.pos ub uc φb φc)
                       (Hom.pos vb vc ψb ψc) m1 s1 s1' ->
            Tpl.step g (ua,ub) (va,vb) (ileft (ua,ub,uc) (va,vb,vc) t)
                       (Hom.pos ua ub φa φb)
                       (Hom.pos va vb ψa ψb) m2 s2 s2' ->
            step 

  ->
            Tpl.step g (ua,uc) (va,vc) (ileft (ua,ub,uc) (va,vb,vc) t) ->

            @step (u,u) (v,v) (Tcc t) (Hom.pos u u φ φ) (Hom.pos v v ψ ψ) m (st φ) (st ψ).
  End Comp.






(** ** Homomorphisms *)


(** Games for a template T are a quiver indexed by T. *)

Definition game {V} (T : template V) (Q : V -> Type) :=
  forall t1 t2, T t1 t2 -> Q t1 -> Q t2 -> Type.


(** * Signature *)

Record sig {V} (T : template V) :=
  {
    phase : V -> Type;
    op : forall u v, T u v -> phase u -> phase v -> Type;
  }.



Definition multisig {S K} (op : S -> K -> Type) (arg : K -> S -> Type) : sig Tgame :=
  {|
    phase v := match v with ⊕ => S | ⊖ => K end;
    op u v t := match t in Tgame u v return 
match u with ⊕ => S | ⊖ => K end ->
match v with ⊕ => S | ⊖ => K end ->
Type
with O => op | P => arg end;
  |}.


(** Single-sorted effect signature *)

Inductive sig_phase : polarity -> Type :=
  | sig_pos : sig_phase ⊕
  | sig_neg (ar : Type) : sig_phase ⊖.

Inductive sig_of (E : Type -> Type) : game Tgame sig_phase :=
  | sig_op ar : E ar -> sig_of E ⊕ ⊖ O sig_pos (sig_neg ar)
  | sig_arg ar : sig_of E ⊖ ⊕ P (sig_neg ar) sig_pos.




(** * Strategies *)

(** ** Template *)

(** * Interactions *)





(** Template of strategies *)

Inductive Tstrat



(** * Transition system for a game *)

Record ts {V} {T : template V} {Φ : V -> Type} (G : game T Φ) :=
  {
    state : forall {v}, Φ v -> Type;
    step : forall {u v} {t : T u v} {φu : Φ u} {φv : Φ v} (τ : G u v t φu φv),
        state φu -> state φv -> Prop;
  }.


Section QPROD.
  Context {U V} (Tu : template U) (Tv : template V).

  Inductive qprod  : template (U * V) :=
    | qpair {u v u' v'} : Tu u u' -> Tv v v' -> qprod (u,v) (u',v').

  Definition qfst : tmor qprod Tu fst :=
    fun _ _ '(qpair t _) => t.

  Definition qsnd : tmor qprod Tv snd :=
    fun _ _ '(qpair _ t) => t.

  Inductive fibrate (f : U -> V) (P : U -> Type) : V -> Type :=
    | fib {u} : P u -> fibrate f P (f u).

  Inductive cofibrate (f : U -> V) (P : V -> Type) : U -> Type :=
    | bif {u} : P (f u) -> cofibrate f P u.

End QPROD.


