The files in this directory define general categorical interfaces and
constructions using Rocq's module system. The idea is less to formalize
the categorical concepts, and more to ensure that models with similar
structures follow a uniform interface, and that moderate amounts
of code reuse are possible.

Ultimately, I want us to be able to write things like this,
enumerating the structures we need for a particular application:

    Module Type ObjSem :=
      Category <+ Cartesian
               <+ Tensor
               <+ Before
               <+ CofreeComonoid Bef
               <+ EffectAlgebras
               <+ Enriched CDLat.

Then we could carry out our work independently of a concrete model:

    Module MyThing (C : ObjSem).
      Import C.
    
      ...
    
    End MyThing.

Below I will outline some design principles I used.

# Conventions

## Modules types and modules

In general, for an interface `Foo` we proceed as follows:

  * The module type `FooDefinition` enumerates the data which must be
    provided to define a structure of kind `Foo`.

  * The module `FooTheory` contains standard definitions and properties
    which can be derived from `FooDefinition` and are expected to be
    included with all instances of the structure.

  * The module type `Foo := FooDefinition <+ FooTheory` can be used as
    the overall type for instances of the structure.

Module types and module functors which build further on top of Foo can
depend on an instance of the `Foo` module type, or just `FooDefinition`
in cases where that is sufficient.

For example, the module type `CategoryDefinition` provides standard names
for object and morphism types, a composition operator and its identity,
and their expected properties. The module functor `CategoryTheory C`
provides common definitions and proofs derived from the basic ingredients
provided by the parameter `C : CategoryDefinition`. When `CategoryTheory`
is used with `<+` or `Include` with the parameter left out, Rocq will
attempt to instantiate `C` with the partially defined module into which
`CategoryTheory` is being included. A definition for the category `SET`
may look like the following:

    Module Type Category :=
      CategoryDefinition <+
      CategoryTheory.

    Module SET <: Category.

      (* Objects *)
      Definition t := Type.

      (* Morphisms *)
      Definition m (A B : t) : t := A -> B.

      (* Identity *)
      Definition id {A} : m A A :=
        fun x => x.

      (* Composition *)
      Definition compose {A B C} (g : m B C) (f : m A B) : m B C :=
        fun a => g (f a).

      (* Properties *)
      Proposition compose_id_left :
        ...

      Include CategoryTheory.

      (* We can have more SET-specific definitions here that
        rely on the material provided by [CategoryTheory]. *)

    End SET.

Note that even though this is not declared, the definitions which precede
the `Include` command will satisfy the `CategoryDefinition` interface, so
that they can be used by the common code in `CategoryTheory`.

## Traits

In most cases, in addition to a core interface designated by a noun such
as `Category` or `Functor`, our modules will implement a number of
auxiliary *traits* designated by adjectives such as `Cartesian`, `Enriched`,
`Monoidal`, ... These additional traits follow the same pattern as above
with both a `Definition` interface and `Theory` common code.

Sometimes, an adjective like `Monoidal` can apply to different core
interfaces such as `Category` or `Functor`. In this case the bare name
will be reserved for the more fundamental interface (in this case for
monoidal categories), and the secondary uses can be disambiguated by
prepending the name of the core interface they relate to, as in
`FunctorMonoidal`.

In general, we will want to give names to common combinations of core
interfaces and additional traits, such as `MonoidalCategory`:

    Module Type MonoidalCategory :=
      Category <+
      Monoidal.

    Module Type MonoidalFunctor (C D : MonoidalCategory) :=
      Functor C D <+
      FunctorMonoidal C D.

More specialized combinations can be defined on an as-needed basis; we
will use the name `FooSpec` for a module type which details the interface
implemented by the module `Foo`, and `BarReq` for a module type which
enumerates requirements for the parameter of a module functor `Bar`.

## Naming files

When a Rocq library (say, `Category.v`) which contains a module of the
same name is imported, the name (`Category`) will usually refer to the
nested module defined within the file. However, in some contexts and
especially module expression, it will sometime be necessary to type its
full qualified name (`Category.Category`) to refer to the inner module
rather than the containing file.

To avoid any confusion, we may want to prevent this situation by using
different names for the containing libraries. For example, we may want
to name files in the plural (`Categories.v`, `Functors.v`, ...) where
applicable.

# Tips and tricks

## Dealing with nested modules

Sometimes, multiple instances of the same structure are provided
by a single model. For example, in many cases a category will have
cartesian products (×), coproducts (+), tensor products (⊗) and more,
all of them instances of monoidal structures, which accordingly
should offer consistent interfaces.

To make this possible, we can encapsulate definitions for these
structures into individual submodules. Each submodule can then meet
a particular interface. The Rocq module system allows module types to
require the presence of submodules of particular types. For example,
the property of a particular category being a model of
multiplicative-additive linear logic could be formalized along the
following lines:

    Module Type MALL (C : Category).
      Import C.

      Declare Module With : MonoidalStructure C.
      Declare Module Plus : MonoidalStructure C.
      Declare Module Tens : MonoidalStructure C.
      Declare Module Parr : MonoidalStructure C.

      Parameter dup : forall A, A ~~> With.omap A A.
      (* ... *)

    End MALL.

The expected contents of the nested module can also be written in-line,
for example:

    Module Type MALL (C : Category).
      Import C.

      Module With.
        Include MonoidalStructure C.
        Parameter dup : forall A, A ~~> omap A A.
        (* ... *)
      End With.

      (* ... *)
    End MALL.

There are however some subtleties associated with using nested modules
in this way, having to do with two main issues.

### Nested modules can only be defined all at once

The first issue is that since modules (nested or otherwise) cannot be
``reopened'' once they have been defined, the presence of submodules
interferes with our usual approach to `FooDefinition` interfaces and
`FooTheory` modules. For example, the following code would not work:

    Module Type MALLDefinition (C : Category).
      (* ... *)
      Declare Module With : MonoidalStructureDefinition C.
      (* ... *)
    End MALLDefinition.

    Module MALLTheory (C : Category) (L : MALLDefinition).
      (* ... *)
      Module With.
        Include MonoidalStructureTheory L.With.
      End With.
      (* ... *)
    End MALLTheory.

Specifically, any attempt to use this interface in the way intended
would fail because the module system would consider the `With` module
provided by `MALLTheory` an attempt at redefinition rather than
an extension of the original's contents:

    Module Foo <: MALL.
      (* ... *)
      Module With <: MonoidalStructureDefinition.
        (* ... *)
      End With.
      (* ... *)
      Include MALLTheory.  (* With submodule conflicts with the one above *)
    End Foo.

This means that our `FooDefinition`/`FooTheory` pattern can only operate
at the level of the submodule itself, and the outer definition module type
must usually `Declare` and already complete `Module` of type `Foo`. 
The [monoidal category](MonoidalCategory.v) interfaces provide some
examples.

### We cannot refer to the enclosing module

In turn, the problem described above amplifies another difficulty.
When a module is being defined, there is no way to refer to it directly.
In general, this can be worked around thanks to the behavior of
`Include` on partially applied module functors, which can use the
current module to instantiate missing parameters. However, in the
context of a submodule, the submodule becomes this "current module"
and we lose any way to use the enclosing module as a parameter.

For example, this problem comes up when defining monoidal structures
as submodules of some category. The `MoniodalStructureTheory` module
functor requires the enclosing category to be provided as a parameter,
but this is impossible as we cannot refer to the enclosing module in
this context:

    Module SomeMonCat <: MonoidalCategory.

      (* ...usual category definitions... *)

      Include CategoryTheory.

      (* ...any additional definitions used by tensor products... *)

      Module Tens <: MonoidalStructure.

        (* ...define bifunctor, isomorphisms, etc... *)

        Include MonoidalStructureTheory XXX. (* cannot refer to SomeMonCat *)
      End Tens.

    End SomeMonCat.

To work around this issue, we need to proceed as follows:

  * First, define a base module containing everything in the enclosing
    module that the submodule requires.
  * Then defined a module *functor* whose parameter will be the base
    module, and whose role will be to define one of more submodules.
  * Finally, define the total module by include first the base module,
    then the submodule-containing functor, whose "base" parameter will
    be implicitly instantiated by the total module being defined.

For example, this strategy is used to define the
[Sig](../models/EffectSignatures.v) category, which provides various
monoidal structures. To implement it, we must also introduce a module
*type* which captures the contents of the base module, so that the
submodule-defining module may use the definitions provided therein.
This is discussed below.

## Module functor instances

Sometimes, when working with module functors, it is useful to know
that a particular module was built in a certain way. For example,
the *free category* construction builds a category from a mere quiver
(a directed multigraph with no composition structure):

    Module FreeCategory (Q : Quiver) <: Category.
      ...
    End FreeCategory.

Then, if given a target category `D : Category` along with a quiver
homomorphism `F : QuiverHomomorphism Q D`, we can define a proper
`Functor` from the free category generated by `Q` into `D`.

However, this functor can only be defined once we have built
an instance of the free category using the module functor above:

    Module C := FreeCategory Q.

    Module IntF : Functor C D.
      ...
      (* Here we interpret the morphisms of [C] (paths in [Q])
       using the mapping provided by [F] and the composition
       operation in [D].  *)
      ...
    End IntF.

To make this construction into a generic module functor, we need
to reify the fact that `C` was constructed as a free category
generated by `Q` into a module type:

    Module Type FreeCategoryInstance (Q : Quiver).
      Include FreeCategory Q.
    End FreeCategoryInstance.

We can then define

    Module IntF (Q : Quiver) (C : FreeCategoryInstance Q) (D : Category)
        (F : QuiverHomomorphism Q D) <: Functor C D.
      ...
    End IntF.

as a construction which can be used with any free category.

In general, we will use the name `FooInstance` for module types
used in this way.

